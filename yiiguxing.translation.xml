<application>
  <component name="AppStorage">
    <option name="newTranslationDialogCollapseDictViewer" value="false" />
    <option name="newTranslationDialogHeight" value="232" />
    <option name="newTranslationDialogWidth" value="518" />
    <option name="newTranslationDialogX" value="826" />
    <option name="newTranslationDialogY" value="470" />
    <histories>
      <item value="lifter" />
      <item value="Plain" />
      <item value="Constraints" />
      <item value="SPEAKER PHONE" />
      <item value="set Web Rtc Based Acoustic Echo Canceler" />
      <item value="set Web Rtc Based Automatic Gain Control" />
      <item value="use Web Rtc Based Noise Suppressor" />
      <item value="set Web Rtc Based Noise Suppressor" />
      <item value="slient" />
      <item value="enum" />
      <item value="Web Rtc Audio Record" />
      <item value="ENABLE INTERNAL TRACER" />
      <item value="disable Encryption" />
      <item value="set Loopback" />
      <item value="use SDES" />
      <item value="loopback" />
      <item value="disable Network Monitor" />
      <item value="use Open SLES" />
      <item value="disable Built In AEC" />
      <item value="set Blacklist Device For Open SLES Usage" />
      <item value="loudspeaker" />
      <item value="Terminal flow operator that collects the given flow but ignores all emitted values. If any exception occurs during collect or in the provided flow, this exception is rethrown from this method. It is a shorthand for `collect {}`. This operator is usually used with [onEach], [onCompletion] and [catch] operators to process all emitted values and handle an exception that might occur in the upstream flow or during processing, for example:" />
      <item value="Terminal flow operator that [launches][launch] the [collection][collect] of the given flow in the [scope]. It is a shorthand for `scope.launch { flow.collect() }`. This operator is usually used with [onEach], [onCompletion] and [catch] operators to process all emitted values handle an exception that might occur in the upstream flow or during processing, for example:" />
      <item value="Terminal flow operator that [launches][launch] the [collection][collect] of the given flow in the [scope]. It is a shorthand for `scope.launch { flow.collect() }`. This operator is usually used with [onEach], [onCompletion] and [catch] operators to process all emitted values handle an exception that might occur in the upstream flow or during processing, for example: ``` flow .onEach { value -&gt; updateUi(value) } .onCompletion { cause -&gt; updateUi(if (cause == null) &quot;Done&quot; else &quot;Failed&quot;) } .catch { cause -&gt; LOG.error(&quot;Exception: cause&quot;) } .launchIn(uiScope) ``` Note that the resulting value of [launchIn] is not used and the provided scope takes care of cancellation." />
      <item value="```" />
      <item value="Disposable Effect" />
      <item value="operator" />
      <item value="drop While" />
      <item value="Freeze the preferences since any future mutations will break DataStore. If a user tunnels the value out of DataStore and mutates it, this could be problematic. This is a safe cast, since MutablePreferences is the only implementation of Preferences." />
      <item value="Preference" />
      <item value="Preferences" />
      <item value="Eagerly" />
      <item value="Class to store ViewModels. An instance of ViewModelStore must be retained through configuration changes: if an owner of this ViewModelStore is destroyed and recreated due to configuration changes, new instance of an owner should still have the same old instance of ViewModelStore. If an owner of this ViewModelStore is destroyed and is not going to be recreated, then it should call clear() on this ViewModelStore, so ViewModels would be notified that they are no longer used. Use ViewModelStoreOwner.getViewModelStore() to retrieve a ViewModelStore for activities and fragments." />
      <item value="Scope" />
      <item value="[DaggerMissingBinding] androidx.fragment.app.FragmentActivity cannot be provided without an @Inject constructor or an @Provides-annotated method." />
      <item value="regular shared flow -&gt; reset cache" />
      <item value="reset Replay Cache" />
      <item value="Marks declarations in the coroutines that are delicate — they have limited use-case and shall be used with care in general code. Any use of a delicate declaration has to be carefully reviewed to make sure it is properly used and does not create problems like memory and resource leaks. Carefully read documentation of any declaration marked as DelicateCoroutinesApi." />
      <item value="Delicate Coroutines Api" />
      <item value="Sharing is started when the first subscriber appears, immediately stops when the last subscriber disappears (by default), keeping the replay cache forever (by default). It has the following optional parameters: stopTimeoutMillis — configures a delay (in milliseconds) between the disappearance of the last subscriber and the stopping of the sharing coroutine. It defaults to zero (stop immediately). replayExpirationMillis — configures a delay (in milliseconds) between the stopping of the sharing coroutine and the resetting of the replay cache (which makes the cache empty for the shareIn operator and resets the cached value to the original initialValue for the stateIn operator). It defaults to Long.MAX_VALUE (keep replay cache forever, never reset buffer). Use zero value to expire the cache immediately. This function throws IllegalArgumentException when either stopTimeoutMillis or replayExpirationMillis are negative." />
      <item value="Experimental Unsigned Types" />
      <item value="While Subscribed" />
      <item value="tiramisu" />
      <item value="tira" />
      <item value="Creates a property delegate for a single process DataStore. This should only be called once in a file (at the top level), and all usages of the DataStore should use a reference the same Instance. The receiver type for the property delegate must be an instance of Context. This should only be used from a single application in a single classloader in a single process. Example usage: val Context.myDataStore by preferencesDataStore(&quot;filename&quot;) class SomeClass(val context: Context) { suspend fun update() = context.myDataStore.edit {...} } 参数: name - The name of the preferences. The preferences will be stored in a file in the &quot;datastore&quot; subdirectory in the application context's files directory and is generated using preferencesDataStoreFile. corruptionHandler - The corruptionHandler is invoked if DataStore encounters a androidx.datastore.core.CorruptionException when attempting to read data. CorruptionExceptions are thrown by serializers when data can not be de-serialized. produceMigrations - produce the migrations. The ApplicationContext is passed in to these callbacks as a parameter. DataMigrations are run before any access to data can occur. Each producer and migration may be run more than once whether or not it already succeeded (potentially because another migration failed or a write to disk failed.) scope - The scope in which IO operations and transform functions will execute. 返回: a property delegate that manages a datastore as a singleton." />
      <item value="toggle Foreground Service" />
      <item value="Used to indicate that the WorkRequest has completed in a failure state. All dependent work will also be marked as FAILED and will never run." />
      <item value="ENQUEUED" />
      <item value="processor" />
      <item value="process" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="1155" />
        <entry key="ENGLISH" value="1156" />
        <entry key="POLISH" value="2" />
        <entry key="GERMAN" value="2" />
        <entry key="RUSSIAN" value="1" />
        <entry key="FRENCH" value="12" />
        <entry key="DUTCH" value="1" />
        <entry key="CATALAN" value="3" />
        <entry key="KANNADA" value="1" />
        <entry key="LATIN" value="2" />
        <entry key="ROMANIAN" value="2" />
        <entry key="JAPANESE" value="4" />
        <entry key="SWEDISH" value="2" />
        <entry key="WELSH" value="2" />
        <entry key="SPANISH" value="1" />
        <entry key="GREEK" value="3" />
        <entry key="HUNGARIAN" value="1" />
        <entry key="ITALIAN" value="2" />
        <entry key="HINDI" value="3" />
        <entry key="INDONESIAN" value="2" />
        <entry key="VIETNAMESE" value="1" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1653351991123" />
  </component>
</application>