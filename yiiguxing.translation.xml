<application>
  <component name="AppStorage">
    <histories>
      <item value="Configures Gson to exclude all fields from consideration for serialization or deserialization that do not have the {@link com.google.gson.annotations.Expose} annotation. @return a reference to this {@code GsonBuilder} object to fulfill the &quot;Builder&quot; pattern" />
      <item value="alternative" />
      <item value="If {@code true}, the field marked with this annotation is written out in the JSON while serializing. If {@code false}, the field marked with this annotation is skipped from the serialized output. Defaults to {@code true}. @since 1.4" />
      <item value="set Lenient" />
      <item value="Use JsonReader.setLenient(true) to accept malformed JSON at line 1 column 1 path $" />
      <item value="Penetration" />
      <item value="which" />
      <item value="Use this annotation on a service method param when you want to directly control the request body of a POST/PUT request (instead of sending in as request parameters or form-style request body). The object will be serialized using the {@link Retrofit Retrofit} instance {@link Converter Converter} and the result will be set directly as the request body. &lt;p&gt;Body parameters may not be {@code null}." />
      <item value="will" />
      <item value="&lt;b&gt;Note:&lt;/b&gt; only alarms for which there is a strong demand for exact-time * delivery (such as an alarm clock ringing at the requested time) should be * scheduled as exact. Applications are strongly discouraged from using exact * alarms unnecessarily as they reduce the OS's ability to minimize battery use." />
      <item value="Flag indicating that if the described PendingIntent already exists, * the current one should be canceled before generating a new one. * For use with {@link #getActivity}, {@link #getBroadcast}, and * {@link #getService}. &lt;p&gt;You can use * this to retrieve a new PendingIntent when you are only changing the * extra data in the Intent; by canceling the previous pending intent, * this ensures that only entities given the new data will be able to * launch it. If this assurance is not an issue, consider * {@link #FLAG_UPDATE_CURRENT}." />
      <item value="Flag indicating that this PendingIntent can be used only once. * For use with {@link #getActivity}, {@link #getBroadcast}, and * {@link #getService}. &lt;p&gt;If set, after * {@link #send()} is called on it, it will be automatically * canceled for you and any future attempt to send through it will fail." />
      <item value="This method is like {@link #set(int, long, PendingIntent)}, but does not permit * the OS to adjust the delivery time. The alarm will be delivered as nearly as * possible to the requested trigger time." />
      <item value="Schedule an alarm to be delivered precisely at the stated time. * * &lt;p&gt; * This method is like {@link #set(int, long, PendingIntent)}, but does not permit * the OS to adjust the delivery time. The alarm will be delivered as nearly as * possible to the requested trigger time. * * &lt;p&gt; * &lt;b&gt;Note:&lt;/b&gt; only alarms for which there is a strong demand for exact-time * delivery (such as an alarm clock ringing at the requested time) should be * scheduled as exact. Applications are strongly discouraged from using exact * alarms unnecessarily as they reduce the OS's ability to minimize battery use. * * @param type type of alarm. * @param triggerAtMillis time in milliseconds that the alarm should go * off, using the appropriate clock (depending on the alarm type). * @param operation Action to perform when the alarm goes off; * typically comes from {@link PendingIntent#getBroadcast * IntentSender.getBroadcast()}." />
      <item value="Schedule a repeating alarm. &lt;b&gt;Note: for timing operations (ticks, * timeouts, etc) it is easier and much more efficient to use * {@link android.os.Handler}.&lt;/b&gt; If there is already an alarm scheduled * for the same IntentSender, it will first be canceled. * * &lt;p&gt;Like {@link #set}, except you can also supply a period at which * the alarm will automatically repeat. This alarm continues * repeating until explicitly removed with {@link #cancel}. If the stated * trigger time is in the past, the alarm will be triggered immediately, with an * alarm count depending on how far in the past the trigger time is relative * to the repeat interval. * * &lt;p&gt;If an alarm is delayed (by system sleep, for example, for non * _WAKEUP alarm types), a skipped repeat will be delivered as soon as * possible. After that, future alarms will be delivered according to the * original schedule; they do not drift over time. For example, if you have * set a recurring alarm for the top of every hour but the phone was asleep * from 7:45 until 8:45, an alarm will be sent as soon as the phone awakens, * then the next alarm will be sent at 9:00. * * &lt;p&gt;If your application wants to allow the delivery times to drift in * order to guarantee that at least a certain time interval always elapses * between alarms, then the approach to take is to use one-time alarms, * scheduling the next one yourself when handling each alarm delivery. * * &lt;p class=&quot;note&quot;&gt; * &lt;b&gt;Note:&lt;/b&gt; as of API 19, all repeating alarms are inexact. If your * application needs precise delivery times then it must use one-time * exact alarms, rescheduling each time as described above. Legacy applications * whose {@code targetSdkVersion} is earlier than API 19 will continue to have all * of their alarms, including repeating alarms, treated as exact." />
      <item value="@param intervalMillis interval in milliseconds between subsequent repeats * of the alarm." />
      <item value="Flag indicating that if the described PendingIntent already exists, * then keep it but replace its extra data with what is in this new * Intent. For use with {@link #getActivity}, {@link #getBroadcast}, and * {@link #getService}. &lt;p&gt;This can be used if you are creating intents where only the * extras change, and don't care that any entities that received your * previous PendingIntent will be able to launch it with your new * extras even if they are not explicitly given to it." />
      <item value="Flag indicating that if the described PendingIntent does not * already exist, then simply return null instead of creating it. * For use with {@link #getActivity}, {@link #getBroadcast}, and * {@link #getService}." />
      <item value="Converts this duration to a Period instance using the standard period type * and the ISO chronology. * &lt;p&gt; * Only precise fields in the period type will be used. Thus, only the hour, * minute, second and millisecond fields on the period will be used. * The year, month, week and day fields will not be populated. * &lt;p&gt; * If the duration is small, less than one day, then this method will perform * as you might expect and split the fields evenly. * If the duration is larger than one day then all the remaining duration will * be stored in the largest available field, hours in this case. * &lt;p&gt; * For example, a duration effectively equal to (365 + 60 + 5) days will be * converted to ((365 + 60 + 5) * 24) hours by this constructor. * &lt;p&gt; * For more control over the conversion process, you must pair the duration with * an instant, see {@link Period#Period(ReadableInstant,ReadableDuration)}. * * @return a Period created using the millisecond duration from this instance" />
      <item value="onverts this duration to a Period instance using the standard period type * and the ISO chronology. * &lt;p&gt; * Only precise fields in the period type will be used. Thus, only the hour, * minute, second and millisecond fields on the period will be used. * The year, month, week and day fields will not be populated. * &lt;p&gt; * If the duration is small, less than one day, then this method will perform * as you might expect and split the fields evenly. * If the duration is larger than one day then all the remaining duration will * be stored in the largest available field, hours in this case. * &lt;p&gt; * For example, a duration effectively equal to (365 + 60 + 5) days will be * converted to ((365 + 60 + 5) * 24) hours by this constructor. * &lt;p&gt; * For more control over the conversion process, you must pair the duration with * an instant, see {@link Period#Period(ReadableInstant,ReadableDuration)}. * * @return a Period created using the millisecond duration from this instance" />
      <item value="隐蔽" />
      <item value="机动投送" />
      <item value="transitive" />
      <item value="BACKEND" />
      <item value="FRONTEND" />
      <item value="lzl" />
      <item value="female" />
      <item value="/** Cache of alternate months format. */" />
      <item value="Gets the value as a String in the ISO8601 duration format including * only seconds and milliseconds. * &lt;p&gt; * For example, &quot;PT72.345S&quot; represents 1 minute, 12 seconds and 345 milliseconds. * &lt;p&gt; * For more control over the output, see * {@link org.joda.time.format.PeriodFormatterBuilder PeriodFormatterBuilder}. * * @return the value as an ISO8601 string" />
      <item value="set Milestones" />
      <item value="Millis" />
      <item value="i Millis" />
      <item value="get Abbreviation" />
      <item value="MILES" />
      <item value="MILLIMETERS" />
      <item value="METERS" />
      <item value="KILOMETERS" />
      <item value="INCHES" />
      <item value="FEET" />
      <item value="draw Arc" />
      <item value="draw Compass Circum" />
      <item value="nearest Coordinate" />
      <item value="fraction Along" />
      <item value="Along" />
      <item value="fraction" />
      <item value="distance Geodetic" />
      <item value="Segment" />
      <item value="Immutable Part" />
      <item value="get Azimuth 1" />
      <item value="Scene View" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="435" />
        <entry key="ENGLISH" value="436" />
        <entry key="POLISH" value="1" />
        <entry key="FRENCH" value="2" />
        <entry key="CATALAN" value="2" />
        <entry key="KANNADA" value="1" />
        <entry key="LATIN" value="2" />
        <entry key="ROMANIAN" value="1" />
        <entry key="SWEDISH" value="1" />
        <entry key="WELSH" value="2" />
        <entry key="GREEK" value="3" />
        <entry key="ITALIAN" value="2" />
        <entry key="HINDI" value="1" />
        <entry key="INDONESIAN" value="2" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
    <option name="overrideFont" value="true" />
    <option name="phoneticFontFamily" value="Consolas" />
  </component>
</application>