<application>
  <component name="AppStorage">
    <option name="newTranslationDialogWidth" value="594" />
    <option name="newTranslationDialogX" value="826" />
    <option name="newTranslationDialogY" value="470" />
    <option name="pinNewTranslationDialog" value="true" />
    <histories>
      <item value="Creates a new array with the specified [size], where each element is calculated by calling the specified [init] function. The function [init] is called for each array element sequentially starting from the first one. It should return the value for an array element given its index." />
      <item value="run For Multiple Inputs Outputs" />
      <item value="Compute the FPS of the entire pipeline" />
      <item value="prediction" />
      <item value="Intrinsic for converting an Android YUV buffer to RGB. The input allocation should be supplied in a supported YUV format as a YUV element Allocation. The output is RGBA; the alpha channel will be set to 255." />
      <item value="Get the YUV data in byte array form using NV21 format" />
      <item value="Copy from the Allocation into a {@link android.graphics.Bitmap}. The bitmap must match the dimensions of the Allocation. @param b The bitmap to be set from the Allocation." />
      <item value="pixel Stride" />
      <item value="Take into account that the stride may include data from pixels other than this particular plane and row, and that could be between pixels and not after every pixel: |---- Pixel stride ----| Row ends here --&gt; | | Pixel 1 | Other Data | Pixel 2 | Other Data | ... | Pixel N | We need to get (N-1) (pixel stride bytes) per row + 1 byte for the last pixel" />
      <item value="For NV21 format, V is in even-numbered indices" />
      <item value="For NV21 format, U is in odd-numbered indices" />
      <item value="Get the array of pixel planes for this Image. The number of planes is determined by the format of the Image. The application will get an empty array if the image format is {@link android.graphics.ImageFormatPRIVATE PRIVATE}, because the image pixel data is not directly accessible. The application can check the image format by calling {@link ImagegetFormat()}." />
      <item value="Get the crop rectangle associated with this frame. &lt;p&gt; The crop rectangle specifies the region of valid pixels in the image, using coordinates in the largest-resolution plane." />
      <item value="planes" />
      <item value="&lt;p&gt; This class provides the primary method through which data is passed to and from RenderScript kernels. An Allocation provides the backing store for a given {@link android.renderscript.Type}. &lt;p&gt;" />
      <item value="Bits per pixel is an average for the whole image, so it's useful to compute the size of the full buffer but should not be used to determine pixel offsets" />
      <item value="new Single Thread Executor" />
      <item value="Backpressure" />
      <item value="STRATEGY KEEP ONLY LATEST" />
      <item value="LENS FACING BACK" />
      <item value="计算&#10;" />
      <item value="This method is invoked on the worker thread with a request to process. Only one Intent is processed at a time, but the processing happens on a worker thread that runs independently from other application logic. So, if this code takes a long time, it will hold up other requests to the same IntentService, but it will not hold up anything else. When all requests have been handled, the IntentService stops itself, so you should not call {@link stopSelf}. @param intent The value passed to {@link android.content.ContextstartService(Intent)}. This may be null if the service is being restarted after its process has gone away; see {@link android.app.ServiceonStartCommand} for details." />
      <item value="Creates an IntentService. Invoked by your subclass's constructor. @param name Used to name the worker thread, important only for debugging." />
      <item value="Constant to return from {@link onStartCommand}: if this service's process is killed while it is started (after returning from {@link onStartCommand}), then leave it in the started state but don't retain this delivered intent. Later the system will try to re-create the service. Because it is in the started state, it will guarantee to call {@link onStartCommand} after creating the new service instance; if there are not any pending start commands to be delivered to the service, it will be called with a null intent object, so you must take care to check for this. &lt;p&gt;This mode makes sense for things that will be explicitly started and stopped to run for arbitrary periods of time, such as a service performing background music playback." />
      <item value="parse Subscription From Element" />
      <item value="EXTRA ALLOW PROVISIONING" />
      <item value="FLAG ACTIVITY NO ANIMATION" />
      <item value="STYLE SPINNER" />
      <item value="Build off of nightly TensorFlow Lite" />
      <item value="Patches the application context class loader by appending extra dex files loaded from the application apk. This method should be called in the attachBaseContext of your {@link Application}, see {@link MultiDexApplication} for more explanation and an example. @param context application context. @throws RuntimeException if an error occurred preventing the classloader extension." />
      <item value="ACTION POST CONNECTIVITY CHANGE" />
      <item value="origin" />
      <item value="Uncomment" />
      <item value="遥控" />
      <item value="yaok" />
      <item value="spotless" />
      <item value="failed to resolve types" />
      <item value="serif" />
      <item value="typeface" />
      <item value="text Appearance Small Inverse" />
      <item value="Interactive" />
      <item value="interactive" />
      <item value="from" />
      <item value="Prepare" />
      <item value="prepare" />
      <item value="No Class Def Found Error" />
      <item value="Failed resolution of:" />
      <item value="A {@code Future} represents the result of an asynchronous computation. Methods are provided to check if the computation is complete, to wait for its completion, and to retrieve the result of the computation. The result can only be retrieved using method {@code get} when the computation has completed, blocking if necessary until it is ready. Cancellation is performed by the {@code cancel} method. Additional methods are provided to determine if the task completed normally or was cancelled. Once a computation has completed, the computation cannot be cancelled. If you would like to use a {@code Future} for the sake of cancellability but not provide a usable result, you can declare types of the form {@code Future&lt;?&gt;} and return {@code null} as a result of the underlying task." />
      <item value="expected" />
      <item value="aka" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="605" />
        <entry key="ENGLISH" value="606" />
        <entry key="POLISH" value="1" />
        <entry key="GERMAN" value="1" />
        <entry key="FRENCH" value="10" />
        <entry key="CATALAN" value="2" />
        <entry key="KANNADA" value="1" />
        <entry key="LATIN" value="2" />
        <entry key="ROMANIAN" value="1" />
        <entry key="JAPANESE" value="4" />
        <entry key="SWEDISH" value="2" />
        <entry key="WELSH" value="2" />
        <entry key="SPANISH" value="1" />
        <entry key="GREEK" value="3" />
        <entry key="HUNGARIAN" value="1" />
        <entry key="ITALIAN" value="2" />
        <entry key="HINDI" value="3" />
        <entry key="INDONESIAN" value="2" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1609816170546" />
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
    <option name="overrideFont" value="true" />
    <option name="phoneticFontFamily" value="Arial" />
    <option name="primaryFontFamily" value="SimSun" />
  </component>
</application>