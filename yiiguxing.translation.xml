<application>
  <component name="AppStorage">
    <option name="newTranslationDialogCollapseDictViewer" value="false" />
    <option name="newTranslationDialogWidth" value="550" />
    <option name="newTranslationDialogX" value="826" />
    <option name="newTranslationDialogY" value="470" />
    <option name="pinNewTranslationDialog" value="true" />
    <histories>
      <item value="set Web View Data Directory Suffix" />
      <item value="View" />
      <item value="feedback" />
      <item value="feedback&#10;" />
      <item value="feedba" />
      <item value="feed" />
      <item value="PBC" />
      <item value="A key response is received from the license server by the app, then it is provided to the DRM engine plugin using provideKeyResponse. When the response is for an offline key request, a key-set identifier is returned that can be used to later restore the keys to a new session with the method {@ link restoreKeys}. When the response is for a streaming or release request, null is returned. @param keySetId When the response is for a release request, keySetId identifie the saved key associated with the release request (i.e., the same keySetId passed to the earlier {@ link getKeyRequest} call. It MUST be null when the response is for either streaming or offline key requests. @param response the byte array response from the server @throws NoDrmSchemeException if there is no active DRM session @throws DeniedByServerException if the response indicates that the server rejected the request" />
      <item value="set Pressed" />
      <item value="indeterminate" />
      <item value="default" />
      <item value="rsb indicator height" />
      <item value="indicator" />
      <item value="rsb thumb scale ratio" />
      <item value="rsb thumb inactivated drawable" />
      <item value="thumb" />
      <item value="switch Receive Mode" />
      <item value="The channel to the framework has been disconnected. Application could try re-initializing using {@link initialize}" />
      <item value="on Channel Disconnected" />
      <item value="Disconnected" />
      <item value="on Disconnected" />
      <item value="on Dis Connected" />
      <item value="group Formed" />
      <item value="progress" />
      <item value="剩余长度" />
      <item value="剩余" />
      <item value="sheng" />
      <item value="A data output stream lets an application write primitive Java data types to an output stream in a portable way. An application can then use a data input stream to read the data back in." />
      <item value="is Restricted" />
      <item value="The requested Bonjour service response is available. &lt;p&gt;This function is invoked when the device with the specified Bonjour registration type returned the instance name. @param instanceName instance name.&lt;br&gt; e.g) &quot;MyPrinter&quot;. @param registrationType &lt;br&gt; e.g) &quot;_ipp._tcp.local.&quot; @param srcDevice source device." />
      <item value="INSTANCE NAME" />
      <item value="Add a service discovery request. &lt;p&gt; The function call immediately returns after sending a request to add service discovery request to the framework. The application is notified of a success or failure to add service through listener callbacks {@link ActionListeneronSuccess} or {@link ActionListeneronFailure}. &lt;p&gt;After service discovery request is added, you can initiate service discovery by {@link discoverServices}. &lt;p&gt;The added service requests can be cleared with calls to {@link removeServiceRequest(Channel, WifiP2pServiceRequest, ActionListener)} or {@link clearServiceRequests(Channel, ActionListener)}. @param c is the channel created at {@link initialize} @param req is the service discovery request. @param listener for callbacks on success or failure. Can be null." />
      <item value="DNS based service discovery protocol." />
      <item value="A class for creating a Bonjour service discovery request for use with {@link WifiP2pManageraddServiceRequest} and {@link WifiP2pManagerremoveServiceRequest} {@see WifiP2pManager} {@see WifiP2pServiceRequest} {@see WifiP2pUpnpServiceRequest}" />
      <item value="Interface for callback invocation when Bonjour service discovery response is received" />
      <item value="Interface for callback invocation when Bonjour TXT record is available for a service" />
      <item value="serviceType service type.&lt;br&gt; e.g) &quot;_ipp._tcp&quot;" />
      <item value="receiver" />
      <item value="receive" />
      <item value="Passed with {@link ActionListeneronFailure}. Indicates that the operation failed because the framework is busy and unable to service the request" />
      <item value="Returns a pseudorandom, uniformly distributed {@code int} value between 0 (inclusive) and the specified value (exclusive), drawn from this random number generator's sequence. The general contract of {@code nextInt} is that one {@code int} value in the specified range is pseudorandomly generated and returned. All {@code bound} possible {@code int} values are produced with (approximately) equal probability. The method {@code nextInt(int bound)} is implemented by class {@code Random} as if by: &lt;pre&gt; {@code public int nextInt(int bound) { if (bound &lt;= 0) throw new IllegalArgumentException(&quot;bound must be positive&quot;); if ((bound &amp; -bound) == bound) i.e., bound is a power of 2 return (int)((bound (long)next(31)) &gt;&gt; 31); int bits, val; do { bits = next(31); val = bits % bound; } while (bits - val + (bound-1) &lt; 0); return val; }}&lt;pre&gt; &lt;p&gt;The hedge &quot;approximately&quot; is used in the foregoing description only because the next method is only approximately an unbiased source of independently chosen bits. If it were a perfect source of randomly chosen bits, then the algorithm shown would choose {@code int} values from the stated range with perfect uniformity. &lt;p&gt; The algorithm is slightly tricky. It rejects values that would result in an uneven distribution (due to the fact that 2^31 is not divisible by n). The probability of a value being rejected depends on n. The worst case is n=2^30+1, for which the probability of a reject is 12, and the expected number of iterations before the loop terminates is 2. &lt;p&gt; The algorithm treats the case where n is a power of two specially: it returns the correct number of high-order bits from the underlying pseudo-random number generator. In the absence of special treatment, the correct number of &lt;i&gt;low-order&lt;i&gt; bits would be returned. Linear congruential pseudo-random number generators such as the one implemented by this class are known to have short periods in the sequence of values of their low-order bits. Thus, this special case greatly increases the length of the sequence of values returned by successive calls to this method if n is a small power of two. @param bound the upper bound (exclusive). Must be positive. @return the next pseudorandom, uniformly distributed {@code int} value between zero (inclusive) and {@code bound} (exclusive) from this random number generator's sequence @throws IllegalArgumentException if bound is not positive @since 1.2" />
      <item value="Creates a new random number generator using a single {@code long} seed. The seed is the initial value of the internal state of the pseudorandom number generator which is maintained by method {@link next}. &lt;p&gt;The invocation {@code new Random(seed)} is equivalent to: &lt;pre&gt; {@code Random rnd = new Random(); rnd.setSeed(seed);}&lt;pre&gt; @param seed the initial seed @see setSeed(long)" />
      <item value="android.app.IntentReceiverLeaked: Service leavesc.hello.filetransfer.service.SendFilesService has leaked IntentReceiver leavesc.hello.filetransfer.broadcast.DirectBroadcastReceiver@f60e7c7 that was originally registered here. Are you missing a call to unregisterReceiver()?" />
      <item value="Service leavesc.hello.filetransfer.service.SendFilesService has leaked IntentReceiver leavesc.hello.filetransfer.broadcast.DirectBroadcastReceiver@f60e7c7 that was originally registered here. Are you missing a call to unregisterReceiver()? android.app.IntentReceiverLeaked: Service leavesc.hello.filetransfer.service.SendFilesService has leaked IntentReceiver leavesc.hello.filetransfer.broadcast.DirectBroadcastReceiver@f60e7c7 that was originally registered here. Are you missing a call to unregisterReceiver()?" />
      <item value="seed" />
      <item value="useful" />
      <item value="Potal" />
      <item value="arrow" />
      <item value="附件" />
      <item value="reason" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="773" />
        <entry key="ENGLISH" value="774" />
        <entry key="POLISH" value="2" />
        <entry key="GERMAN" value="2" />
        <entry key="FRENCH" value="12" />
        <entry key="CATALAN" value="2" />
        <entry key="KANNADA" value="1" />
        <entry key="LATIN" value="2" />
        <entry key="ROMANIAN" value="2" />
        <entry key="JAPANESE" value="4" />
        <entry key="SWEDISH" value="2" />
        <entry key="WELSH" value="2" />
        <entry key="SPANISH" value="1" />
        <entry key="GREEK" value="3" />
        <entry key="HUNGARIAN" value="1" />
        <entry key="ITALIAN" value="2" />
        <entry key="HINDI" value="3" />
        <entry key="INDONESIAN" value="2" />
        <entry key="VIETNAMESE" value="1" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1620958999751" />
  </component>
  <component name="Settings">
    <option name="overrideFont" value="true" />
    <option name="phoneticFontFamily" value="Arial" />
    <option name="primaryFontFamily" value="SimSun" />
    <option name="translateDocumentation" value="true" />
  </component>
</application>